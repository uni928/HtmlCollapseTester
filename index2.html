<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>html 表示崩れチェッカー（y座標で判定）</title>
<style>
  :root { --bar-h: 56px; --initw: 375px; --minw:320px; --maxw:2560px; }
  * { box-sizing: border-box; }
  body { margin: 0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif; background:#f6f7f9; color:#222; }
  header { position: sticky; top:0; z-index:5; background:#fff; border-bottom:1px solid #e6e8eb; }
  header .inner { max-width: 1100px; margin: 0 auto; padding: 12px 16px; display: grid; gap: 8px; }
  h1 { font-size: 16px; margin: 0; }
  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .row label { font-weight:600; width:72px; }
  .row input[type="file"] { flex:1 1 420px; }
  button { appearance:none; border:1px solid #d0d7de; background:#fff; padding:8px 12px; border-radius:8px; font-weight:600; cursor:pointer; }
  button:disabled { opacity:.55; cursor:not-allowed; }
  main { padding: 16px; padding-bottom: calc(var(--bar-h) + 16px); }
  .stage { max-width: calc(var(--maxw) + 20px); margin: 0 auto; }
  .viewport-wrap { background:#fff; border:1px solid #e1e4e8; border-radius:12px; padding:16px; box-shadow:0 1px 2px rgba(0,0,0,.04); }
  .viewport { width: var(--initw); margin: 0 auto; border:2px solid #dbe0e6; border-radius:8px; background:#f8fafc; }
  .viewport iframe { display:block; width:100%; height:400px; border:0; border-radius:6px; background:#fff; }
  /* 最下部の帯 */
  .bar { position:fixed; inset-inline:0; bottom:0; z-index:10; height:var(--bar-h); display:grid; grid-template-columns:auto 1fr auto; align-items:center; gap:10px; padding:8px 12px; background:rgba(255,255,255,.92); backdrop-filter:saturate(1.2) blur(6px); border-top:1px solid #e4e8ee; }
  .pill { padding:6px 10px; border-radius:999px; background:#f1f3f6; border:1px solid #e1e4e8; }
  .num { font: 600 16px/1 tabular-nums, ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  .status { min-width: 10ch; font-size:13px; color:#666; }
  .ghost { opacity:.7; }
  .kbd { font:600 12px/1 ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; padding:2px 6px; border:1px solid #d0d7de; border-radius:6px; background:#f7f9fb; }
  .gear { justify-self:end; }
  .gear-panel { position:fixed; right:10px; bottom:calc(var(--bar-h) + 10px); background:#fff; border:1px solid #dfe3ea; border-radius:10px; padding:10px; box-shadow:0 6px 24px rgba(0,0,0,.08); display:none; min-width:260px; }
  .gear-panel.open { display:block; }
  .gear-panel label { font-size:12px; color:#555; display:block; }
  .gear-panel input[type="number"] { width:100%; padding:6px 8px; margin:4px 0 10px; border:1px solid #d0d7de; border-radius:6px; background:#fafbfc; }
</style>
</head>
<body>
  <header>
    <div class="inner">
      <h1>html 表示崩れチェッカー（y座標で判定）</h1>
      <div class="row">
        <label for="htmlFile">HTML</label>
        <input id="htmlFile" type="file" accept=".html,.htm,text/html">
      </div>
      <div class="row">
        <label for="cssFiles">CSS</label>
        <input id="cssFiles" type="file" accept=".css,text/css" multiple>
      </div>
      <div class="row">
        <label for="jsFiles">JavaScript</label>
        <input id="jsFiles" type="file" accept=".js,application/javascript" multiple>
      </div>

      <div class="row">
        <label for="imgFiles">画像（任意個）</label>
        <input id="imgFiles" type="file" accept="image/*,.svg" multiple>
      </div>
      <div class="row">
        <label class="row" style="width:auto;gap:6px;">
          <input id="pauseAnim" type="checkbox" checked> iframe内のアニメ・遷移停止
        </label>
        <button id="showBtn">表示</button>
        <span id="loadMsg" class="ghost"></span>
      </div>
    </div>
  </header>

  <main>
    <div class="stage">
      <div class="viewport-wrap">
        <div id="viewport" class="viewport" style="width:var(--initw)">
          <iframe id="sandbox" sandbox="allow-scripts allow-same-origin"></iframe>
        </div>
      </div>
    </div>
  </main>

  <div class="bar" role="group" aria-label="幅コントロール">
    <div class="row">
      <button id="prevBtn" title="前の変化へ（左）">←</button>
      <div class="pill"><span class="num" id="widthNum">—</span><span class="ghost"> px</span></div>
      <button id="nextBtn" title="次の変化へ（右）">→</button>
      <span id="status" class="status"></span>
    </div>
    <div class="row ghost">
      <span>ヒント：</span><span class="kbd">←</span>/<span class="kbd">→</span> で操作（境界幅にダイレクトジャンプ）
    </div>
    <div class="row gear">
      <button id="gearBtn" title="探索範囲などを調整">⚙</button>
      <div id="gearPanel" class="gear-panel">
        <label for="minW">最小幅(px)</label><input id="minW" type="number" min="0" value="320">
        <label for="maxW">最大幅(px)</label><input id="maxW" type="number" min="100" value="2560">
        <label for="coarse">粗探索ステップ(px)</label><input id="coarse" type="number" min="1" value="32">
        <label for="maxEls">計測する要素数上限</label><input id="maxEls" type="number" min="50" value="400">
        <label for="quant">高さ丸め(px, 0で丸めなし)</label><input id="quant" type="number" min="0" value="1">
        <label class="row" style="gap:6px;margin-top:6px;">
          <input id="stripHeaderChk" type="checkbox">
          読み込み時にヘッダーを削除
        </label>
        <label for="stripSel">削除セレクタ（カンマ区切り）</label>
        <input id="stripSel" type="text" value="header, [role='banner'], .site-header, #site-header">
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== 設定 =====
  const THRESHOLD_Y = 10; // ← y座標変化の閾値(px)。必要に応じて変更

  // --- DOM 参照 ---
  const htmlFile = document.getElementById('htmlFile');
  const cssFiles = document.getElementById('cssFiles');
  const jsFiles  = document.getElementById('jsFiles');
  const imgFiles = document.getElementById('imgFiles');
  const pauseAnim= document.getElementById('pauseAnim');
  const showBtn  = document.getElementById('showBtn');
  const loadMsg  = document.getElementById('loadMsg');
  const viewport = document.getElementById('viewport');
  const iframe   = document.getElementById('sandbox');

  const prevBtn  = document.getElementById('prevBtn');
  const nextBtn  = document.getElementById('nextBtn');
  const widthNum = document.getElementById('widthNum');
  const statusEl = document.getElementById('status');
  const gearBtn  = document.getElementById('gearBtn');
  const gearPanel= document.getElementById('gearPanel');
  const minWInput= document.getElementById('minW');
  const maxWInput= document.getElementById('maxW');
  const coarseInput=document.getElementById('coarse'); // 互換のため残すが未使用
  const maxElsInput=document.getElementById('maxEls');
  const quantInput=document.getElementById('quant');
  const stripHeaderChk=document.getElementById('stripHeaderChk');
  const stripSelInput=document.getElementById('stripSel');

  let isLoaded = false;
  let currentWidth = parseInt(getComputedStyle(viewport).width) || 375;
  widthNum.textContent = currentWidth;

  // 基準幅でのメタ（高さとtopを保持）
  let baseMeta = { width: currentWidth, mapH: null, mapTop: null, list: [] };

  // --- ヘルパ ---
  const waitFrames = (n=2) => new Promise(res => {
    let i=0; const step=()=> (++i>=n)?res():requestAnimationFrame(step); requestAnimationFrame(step);
  });
  const clamp=(n,lo,hi)=>Math.max(lo,Math.min(hi,n));

  const readAsText = (file) => new Promise((resolve,reject)=>{
    const fr=new FileReader();
    fr.onerror=()=>reject(fr.error);
    fr.onload =()=>resolve(String(fr.result||""));
    fr.readAsText(file);
  });

  // HTML文字列から指定セレクタに一致する要素を削除して返す
  const stripHeaderFromHtml = (htmlText, selectorList) => {
    try {
      const parser = new DOMParser();
      const doc = parser.parseFromString(htmlText, "text/html");
      if (!doc || !doc.documentElement) return htmlText;
      const sel = String(selectorList || "").trim();
      if (!sel) return htmlText;
      doc.querySelectorAll(sel).forEach(node => node.remove());
      // 元HTMLのDOCTYPEを維持
      const hasDoctype = /^<!doctype\s+html[^>]*>/i.test(htmlText);
      const doctype = hasDoctype ? (htmlText.match(/^<!doctype\s+html[^>]*>/i)||[""])[0]+"\n" : "<!doctype html>\n";
      return doctype + doc.documentElement.outerHTML;
    } catch (e) {
      console.warn("stripHeaderFromHtml failed:", e);
      return htmlText; // 失敗時はそのまま
    }
  };

  const setViewportWidth = async (px,{silent=false}={})=>{
    const minW=+minWInput.value||320, maxW=+maxWInput.value||2560;
    currentWidth = clamp(px|0, minW, maxW);
    viewport.style.width = currentWidth + "px";
    if (!silent) widthNum.textContent = String(currentWidth);
    await waitFrames(2);
    try {
      const doc = iframe.contentDocument;
      const h = Math.max(
        doc.body.scrollHeight, doc.documentElement.scrollHeight,
        doc.body.offsetHeight, doc.documentElement.offsetHeight
      );
      iframe.style.height = Math.max(200,h) + "px";
    } catch {}
    await waitFrames(1);
  };

  // --- 要素ID（親>子インデックスの道） ---
  const uidFor = (el) => {
    const parts=[];
    let cur = el;
    while (cur && cur.nodeType===1 && cur !== cur.ownerDocument.documentElement) {
      const parent = cur.parentElement;
      if (!parent) break;
      const idx = Array.prototype.indexOf.call(parent.children, cur);
      parts.push(cur.tagName + "#" + idx);
      cur = parent;
      if (parts.length>512) break;
    }
    return parts.reverse().join(">");
  };

  // ハイライト用スタイル
  const ensureHighlightStyle = ()=>{
    const doc = iframe.contentDocument;
    if (doc.getElementById("__height_change_style__")) return;
    const style = doc.createElement('style');
    style.id="__height_change_style__";
    style.textContent = `
      .__height_changed__ { outline: 2px dashed #d9480f !important; outline-offset: 2px !important; background: rgba(255,136,0,.08) !important; }
      .__height_marker__ { position:absolute; z-index:2147483647; pointer-events:none; border:2px solid #d9480f; border-radius:6px; box-shadow:0 4px 16px rgba(0,0,0,.2); }
      .__height_marker__ .lbl { background:#d9480f; color:#fff; font: 700 12px/1 ui-monospace,monospace; padding:4px 6px; border-bottom-left-radius:6px; border-bottom-right-radius:6px; }
    `;
    (doc.head||doc.documentElement).appendChild(style);
  };
  const clearHighlights = ()=>{
    const doc = iframe.contentDocument;
    if (!doc) return;
    doc.querySelectorAll('.__height_changed__').forEach(el=>el.classList.remove('__height_changed__'));
    doc.querySelectorAll('.__height_marker__').forEach(el=>el.remove());
  };

  // --- 基準収集（高さhとtop/bottom） ---
  const captureBaseMeta = (limit=400, quant=1)=>{
    const doc = iframe.contentDocument;
    if (!doc) return { mapH:new Map(), mapTop:new Map(), list:[] };
    const all = doc.body ? doc.body.querySelectorAll('*') : doc.querySelectorAll('*');
    const mapH = new Map();   // uid -> height
    const mapTop = new Map(); // uid -> top
    const list = [];
    let cnt=0;
    for (let i=0;i<all.length && cnt<limit;i++){
      const el = all[i];
      const rect = el.getBoundingClientRect();
      let h = Math.max(0, Math.round(rect.height));
      if (quant && quant>1) h = Math.round(h/quant)*quant;
      const top = Math.round(rect.top);
      if (h===0) continue;
      const uid = uidFor(el);
      if (!uid) continue;
      mapH.set(uid, h);
      mapTop.set(uid, top);
      list.push({ uid, top, bottom: top + h, height: h, el });
      cnt++;
    }
    list.sort((a,b)=> a.top===b.top ? 0 : a.top - b.top);
    return { mapH, mapTop, list };
  };

  // --- 現在幅：top/height 収集 ---
  const captureNowOrder = (limit=400, quant=1)=>{
    const doc = iframe.contentDocument;
    if (!doc) return [];
    const all = doc.body ? doc.body.querySelectorAll('*') : doc.querySelectorAll('*');
    const order = [];
    let cnt=0;
    for (let i=0;i<all.length && cnt<limit;i++){
      const el = all[i];
      const rect = el.getBoundingClientRect();
      let h = Math.max(0, Math.round(rect.height));
      if (quant && quant>1) h = Math.round(h/quant)*quant;
      const top = Math.round(rect.top);
      if (h===0) continue;
      const uid = uidFor(el);
      if (!uid) continue;
      order.push({ uid, el, top, bottom: top + h, height: h });
      cnt++;
    }
    order.sort((a,b)=> a.top===b.top ? 0 : a.top - b.top);
    return order;
  };

  // --- y座標の変化で判定 ---
const diffY = (base, order)=>{
  const diffs = [];
  for (const now of order) {
    const baseTop = base.mapTop.get(now.uid);
    if (baseTop == null) continue;
    const dy = now.top - baseTop;

    // ★ 閾値を動的に計算
    const threshold = Math.max(THRESHOLD_Y, baseTop / 80);

    if (Math.abs(dy) >= threshold) {
      diffs.push({ uid: now.uid, el: now.el, prevTop: baseTop, currTop: now.top, dy });
    }
  }
  return diffs;
};


  // --- 強調表示（変化後のみ） ---
  const ensureAndClear = ()=>{ ensureHighlightStyle(); clearHighlights(); };
  const highlightDiffs = (diffs)=>{
    const doc = iframe.contentDocument;
    ensureAndClear();
    for (const d of diffs) {
      try {
        d.el.classList.add('__height_changed__');
        const r = d.el.getBoundingClientRect();
        const win = iframe.contentWindow;
        const sx = (win && (win.scrollX || win.pageXOffset)) || 0;
        const sy = (win && (win.scrollY || win.pageYOffset)) || 0;

        const mark = doc.createElement('div');
        mark.className='__height_marker__';
        mark.style.left   = Math.max(0, r.left - 4 + sx) + "px";
        mark.style.top    = Math.max(0, r.top  - 4 + sy) + "px";
        mark.style.width  = Math.max(0, r.width + 8) + "px";
        mark.style.height = Math.max(0, r.height + 8) + "px";

        const lbl = doc.createElement('div');
        lbl.className='lbl';
        lbl.textContent = `y: ${d.prevTop}px → ${d.currTop}px (Δ${d.dy})`;
        mark.appendChild(lbl);
        doc.body.appendChild(mark);
      } catch {}
    }
  };

  // --- 画像アセットのBlob URLマップ ---
  const buildAssetMap = (fileList) => {
    const byName = new Map(); const byLower = new Map();
    for (const f of fileList) {
      const url = URL.createObjectURL(f);
      byName.set(f.name, url);
      byLower.set(f.name.toLowerCase(), url);
    }
    const findAssetURL = (refUrl) => {
      if (!refUrl) return null;
      try {
        const u = new URL(refUrl, "http://local/");
        const path = decodeURIComponent(u.pathname || "");
        const file = path.split("/").filter(Boolean).pop() || "";
        if (!file) return null;
        return byName.get(file) || byLower.get(file.toLowerCase()) || null;
      } catch {
        const clean = String(refUrl).split("?")[0].split("#")[0];
        const file = clean.split("/").filter(Boolean).pop() || "";
        if (!file) return null;
        return byName.get(file) || byLower.get(file.toLowerCase()) || null;
      }
    };
    return { byName, byLower, findAssetURL };
  };

  // CSS内の url(...) をローカル置換
  const rewriteCssTextWithAssets = (cssText, findAssetURL) => {
    if (!cssText) return cssText;
    return cssText.replace(/url\(\s*(['"]?)([^'")]+)\1\s*\)/g, (m, q, url) => {
      const blob = findAssetURL(url);
      return blob ? `url("${blob}")` : m;
    });
  };

  // HTML挿入後にDOM内の参照をローカル置換
  const wireLocalAssetsInDOM = (doc, findAssetURL) => {
    const singleAttrs = [
      ["img","src"], ["video","poster"], ["video","src"], ["audio","src"],
      ["source","src"], ["link[rel~='icon']","href"], ["link[rel~='apple-touch-icon']","href"]
    ];
    for (const [sel, attr] of singleAttrs) {
      doc.querySelectorAll(sel).forEach(el => {
        const v = el.getAttribute(attr);
        const blob = findAssetURL(v);
        if (blob) el.setAttribute(attr, blob);
      });
    }
    const srcsetSel = ["img[srcset]", "source[srcset]"];
    doc.querySelectorAll(srcsetSel.join(",")).forEach(el => {
      const srcset = el.getAttribute("srcset");
      if (!srcset) return;
      const parts = srcset.split(",").map(s=>s.trim()).filter(Boolean);
      const rewritten = parts.map(part=>{
        const sp = part.split(/\s+/);
        const url = sp[0];
        const rest = sp.slice(1).join(" ");
        const blob = findAssetURL(url);
        return (blob || url) + (rest ? " " + rest : "");
      }).join(", ");
      el.setAttribute("srcset", rewritten);
    });
    doc.querySelectorAll("[style]").forEach(el => {
      const st = el.getAttribute("style");
      const rw = rewriteCssTextWithAssets(st, findAssetURL);
      if (rw !== st) el.setAttribute("style", rw);
    });
    doc.querySelectorAll("style").forEach(styleEl => {
      const t = styleEl.textContent;
      const rw = rewriteCssTextWithAssets(t, findAssetURL);
      if (rw !== t) styleEl.textContent = rw;
    });
  };

  const toggleControls = (on)=>{ prevBtn.disabled = nextBtn.disabled = !on; showBtn.disabled = !on; };

  // 表示
  showBtn.addEventListener('click', async ()=>{
    if (!htmlFile.files[0]) { alert("HTMLファイルを1つ選択してください。"); return; }
    toggleControls(false); loadMsg.textContent="読み込み中…"; statusEl.textContent="";
    try {
      let htmlText = await readAsText(htmlFile.files[0]);
      const cssTexts=[]; for (const f of cssFiles.files) cssTexts.push(await readAsText(f));
      const jsTexts=[];  for (const f of jsFiles.files)  jsTexts.push(await readAsText(f));

      // ★ 読み込み時にヘッダーを削除（有効時）
      if (stripHeaderChk?.checked) {
        htmlText = stripHeaderFromHtml(htmlText, stripSelInput?.value || "");
      }

      const assetMap = buildAssetMap(imgFiles.files);

      // 注入
      iframe.srcdoc = "<!doctype html><html><head><meta charset='utf-8'></head><body>Loading…</body></html>";
      await waitFrames(1);
      const doc = iframe.contentDocument;
      doc.open(); doc.write(htmlText || "<!doctype html><p>empty</p>"); doc.close();
      await waitFrames(2);
      const head = doc.head || doc.getElementsByTagName('head')[0] || doc.documentElement;
      for (const css of cssTexts) {
        const style = doc.createElement('style');
        style.textContent = rewriteCssTextWithAssets(css, assetMap.findAssetURL);
        head.appendChild(style);
      }
      if (pauseAnim.checked) {
        const killer = doc.createElement('style');
        killer.textContent="*,*::before,*::after{animation:none!important;transition:none!important}";
        head.appendChild(killer);
      }
      wireLocalAssetsInDOM(doc, assetMap.findAssetURL);
      const body = doc.body || doc.documentElement;
      for (const js of jsTexts) {
        const s = doc.createElement('script'); s.type='text/javascript'; s.textContent = js; body.appendChild(s);
      }

      isLoaded = true;
      await setViewportWidth(currentWidth, {silent:true});
      baseMeta = captureBaseMeta(+maxElsInput.value||400, +quantInput.value||1);
      clearHighlights();
      loadMsg.textContent="読み込み完了";
    } catch(e) {
      console.error(e); alert("読み込み・注入でエラーが発生しました。コンソールをご確認ください。");
      loadMsg.textContent="エラー";
    } finally {
      toggleControls(true); setTimeout(()=>loadMsg.textContent="", 1500);
    }
  });

  // 次の境界（右）—1px リニア
  const findNextBoundary = async ()=>{
    const maxEls = Math.max(50, +maxElsInput.value||400);
    const quant  = Math.max(0, +quantInput.value||1);
    const maxW   = +maxWInput.value||2560;

    await setViewportWidth(currentWidth, {silent:true});
    const base = baseMeta;

    for (let w = currentWidth + 1; w <= maxW; w += 1) {
      if (w % 16 === 0) statusEl.textContent = `スキャン中… ${w}px`;
      await setViewportWidth(w, {silent:true});
      const nowOrder = captureNowOrder(maxEls, quant);
      const diffs = diffY(base, nowOrder);
      if (diffs.length > 0) { statusEl.textContent = ""; return w; }
    }
    statusEl.textContent = "";
    return null;
  };

  // 前の境界（左）—1px リニア
  const findPrevBoundary = async ()=>{
    const maxEls = Math.max(50, +maxElsInput.value||400);
    const quant  = Math.max(0, +quantInput.value||1);
    const minW   = +minWInput.value||320;

    await setViewportWidth(currentWidth, {silent:true});
    const base = baseMeta;

    for (let w = currentWidth - 1; w >= minW; w -= 1) {
      if (w % 16 === 0) statusEl.textContent = `スキャン中… ${w}px`;
      await setViewportWidth(w, {silent:true});
      const nowOrder = captureNowOrder(maxEls, quant);
      const diffs = diffY(base, nowOrder);
      if (diffs.length > 0) { statusEl.textContent = ""; return w + 1; }
    }
    statusEl.textContent = "";
    return null;
  };

  // 右：境界へ
  const goNext = async ()=>{
    if (!isLoaded) { alert("先に「表示」でサイトを読み込んでください。"); return; }
    toggleControls(false); statusEl.textContent="探索中…";
    try {
      const boundary = await findNextBoundary();
      const maxW = +maxWInput.value||2560;
      if (boundary == null) {
        await setViewportWidth(maxW);
        clearHighlights();
        statusEl.textContent="最大幅に到達";
      } else {
        await setViewportWidth(boundary);
        const nowOrder = captureNowOrder(+maxElsInput.value||400, +quantInput.value||1);
        const diffs = diffY(baseMeta, nowOrder);
        highlightDiffs(diffs);
        statusEl.textContent = diffs.length ? `変化 ${diffs.length} 要素 @ ${boundary}px` : `変化なし @ ${boundary}px`;
        baseMeta = captureBaseMeta(+maxElsInput.value||400, +quantInput.value||1);
      }
    } finally { toggleControls(true); }
  };

  // 左：境界へ
  const goPrev = async ()=>{
    if (!isLoaded) { alert("先に「表示」でサイトを読み込んでください。"); return; }
    toggleControls(false); statusEl.textContent="探索中…";
    try {
      const boundary = await findPrevBoundary();
      const minW = +minWInput.value||320;
      if (boundary == null) {
        await setViewportWidth(minW);
        clearHighlights();
        statusEl.textContent="最小幅に到達";
      } else {
        await setViewportWidth(boundary);
        const nowOrder = captureNowOrder(+maxElsInput.value||400, +quantInput.value||1);
        const diffs = diffY(baseMeta, nowOrder);
        highlightDiffs(diffs);
        statusEl.textContent = diffs.length ? `変化 ${diffs.length} 要素 @ ${boundary}px` : `変化なし @ ${boundary}px`;
        baseMeta = captureBaseMeta(+maxElsInput.value||400, +quantInput.value||1);
      }
    } finally { toggleControls(true); }
  };

  nextBtn.addEventListener('click', goNext);
  prevBtn.addEventListener('click', goPrev);

  // キーボードショートカット
  window.addEventListener('keydown', (e)=>{
    if (e.key==='ArrowRight') { e.preventDefault(); goNext(); }
    if (e.key==='ArrowLeft')  { e.preventDefault(); goPrev(); }
  });

  // 歯車
  gearBtn.addEventListener('click', ()=> gearPanel.classList.toggle('open'));
  document.addEventListener('click', (e)=>{
    if (!gearPanel.contains(e.target) && e.target!==gearBtn) gearPanel.classList.remove('open');
  });

  // 初期
  (async ()=>{ await setViewportWidth(currentWidth,{silent:true}); })();
})();
</script>
</body>
</html>
